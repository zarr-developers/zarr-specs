.. This file is in restructured text format: http://docutils.sourceforge.net/rst.html


Zarr core protocol version 3.0
==============================

**Work in Progress**

This version:
    http://purl.org/zarr/spec/protocol/core/3.0/dev
    TODO replace "dev" with a git tag when a draft is tagged, and create a PURL redirecting to RTFD
Latest version:
    http://purl.org/zarr/spec/protocol/core/3.0
Issue tracking:
    `GitHub issues <https://github.com/zarr-developers/zarr-specs/labels/core-protocol-v3.0>`_
Suggest an edit for this spec:
    `GitHub editor <https://github.com/zarr-developers/zarr-specs/blob/core-protocol-v3.0-dev/docs/protocol/core/v3.0.rst>`_

Copyright 2019 `Zarr core development
team <https://github.com/orgs/zarr-developers/teams/core-devs>`_ (@@TODO
list institutions?). This work is licensed under a `Creative Commons
Attribution 3.0 Unported
License <https://creativecommons.org/licenses/by/3.0/>`_.

----


Abstract
--------

This specification defines a core protocol for storage and retrieval
of N-dimensional typed arrays.


Status of this document
-----------------------

This document is a **Work in Progress**. It may be updated, replaced
or obsoleted by other documents at any time. It is inappapropriate to
cite this document as other than work in progress.

Comments, questions or contributions to this document are very
welcome. Comments and questions should be raised via `GitHub issues
<https://github.com/zarr-developers/zarr-specs/labels/core-protocol-v3.0>`_. When
raising an issue, please add the label
"core-protocol-v3.0". Contributions and suggested edits can be made
via GitHub via the `online editor
<https://github.com/zarr-developers/zarr-specs/blob/core-protocol-v3.0-dev/docs/protocol/core/v3.0.rst>`_
or by making a pull request against the "core-protocol-v3.0-dev"
branch.

This document was produced by the `Zarr core development team
<https://github.com/orgs/zarr-developers/teams/core-devs>`_.


Document conventions
--------------------

Conformance requirements are expressed with a combination of
descriptive assertions and [RFC2119]_ terminology. The key words
"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative
parts of this document are to be interpreted as described in
[RFC2119]_. However, for readability, these words do not appear in all
uppercase letters in this specification.

All of the text of this specification is normative except sections
explicitly marked as non-normative, examples, and notes. Examples in
this specification are introduced with the words "for example".


Conceptual model
----------------

A Zarr *hierarchy* is a tree structure, where each node in the tree is
either a *group* or an *array*. Group nodes may have children
but array nodes may not.

Each node in a hierarchy has a *name* which is a string of ASCII
characters with some additional constraints defined in the section on
`Node names`_ below. Two sibling nodes cannot have the same name. The
root node does not have a name.

Each node in a hierarchy has a *path* which uniquely identifies that
node and defines its location within the hierarchy. The path is formed 
by joining together the "/" character, followed by the names of all 
ancestor nodes separated by the "/" character, followed by the name of 
the node itself. For example, the path "/foo/bar" identifies a node 
named "bar", whose parent is named "foo", whose parent is the root of 
the hierarchy. The path "/" identifies the root node.

An array has a fixed number of zero or more *dimensions*. Each dimension has an
integer length. The core protocol only considers the case where the
lengths of all dimensions are finite. However, protocol extensions may
be defined which allow a dimension to have infinite or variable
length.

The *shape* of an array is the tuple of dimension lengths. For
example, if an array has 2 dimensions, where the length of the first
dimension is 100 and the length of the second dimension is 20, then
the shape of the array is (100, 20).

An array contains zero or more *elements*. Each element can be
identified by a tuple of coordinates, one for each dimension of the
array. If all dimensions of an array have finite length, then the
number of elements in the array is given by the product of the
dimension lengths. An array element may be empty, or it may have a
value.

An array is associated with a *data type*. A data type defines the set
of possible values that the array may contain, and a binary
representation (i.e., sequence of bytes) for each possible value. For
example, the little-endian 32-bit signed integer data type defines
binary representations for all integers in the range âˆ’2,147,483,648 to
2,147,483,647. The core protocol only considers a limited set of data
types, but protocol extensions may define other data types.

An array is divided into a set of *chunks*, where each chunk is a
hyperrectangle defined by a tuple of intervals, one for each dimension
of the array. The shape of a chunk is the tuple of interval lengths,
and the size of a chunk (i.e., number of elements contained within the
chunk) is the product of its interval lengths.

The chunks of an array are organised into a *grid*. The core protocol
only considers the case where all chunks have the same shape and the
chunks form a regular grid. However, protocol extensions may define
other grid types such as rectilinear grids.

An array is associated with a *memory layout* which defines how to
construct a binary representation of a single chunk by organising the
binary values within the chunk into a single contiguous sequence of
bytes. The core protocol defines two types of memory layout based on
"C" (row-major) and "F" (column-major) ordering of values, but
protocol extensions may define other memory layouts.

An array is associated with an *encoding pipeline*, which is a
sequence of zero or more *codecs* that transforms the binary
representation of a chunk in some way. For example, an encoding
pipeline might include a checksum codec to ensure data integrity, and
a compression codec to reduce data size. All codecs implement a common
*codec interface* which provides a pair of operations, one to perform
the transformation (encode), the other to reverse the transformation
(decode).

Each node in a hierarchy is represented by a *metadata document*,
which is a machine-readable document containing essential processing
information about the node. For example, an array metadata document
will specify the number of dimensions, length of each dimension, data
type, chunk shape, memory layout and encoding pipeline for that array.

The metadata and encoded chunk data for all nodes in a hierarchy are
held in a *store*. To enable a variety of different store types to be
used, the core protocol defines a simple *store interface* which is a
common set of operations that a store must provide.


Node names
----------

Except for the root node, each node in a hierarchy must have a name,
which is a string of ASCII characters. To ensure consistent behaviour
across different storage systems, the following constraints apply to
node names:

* must not be the empty string ("")

* must consist only of characters in the sets `a-z`, `A-Z`, `0-9`,
  `-_.`

* must not be a string composed only of period characters, e.g. "." or
  ".."

* must be at most 255 characters long

Note that node names are used to form storage keys, and that some
storage systems will perform a case-insensitive comparison of storage
keys during retrieval. Therefore, within a hierarchy, all nodes within
a set of sibling nodes must have a name that is unique under
case-insensitive comparison. E.g., the names "foo" and "FOO" are not
allowed for sibling nodes.


Data types
----------

A data type describes the set of possible binary values that an array
element may take, along with some information about how the values
should be interpreted.

This protocol defines a limited set of data types to represent Boolean
values, integers, floating point numbers and complex numbers. Protocol
extensions may define additional data types. All of the data types
defined here have a fixed size, in the sense that all values require
the same number of bytes. However, protocol extensions may define
variable sized data types.

Note that the Zarr protocol is intended to enable communication of
data between a variety of computing environments. The native byte
order may differ between machines used to write and read the data.

Each data type is associated with an identifier, which can be used in
metadata documents to refer to the data type. For the data types
defined in this protocol, the identifier is a simple ASCII
string. However, protocol extensions may use any JSON value to
identify a data type.


Core data types
~~~~~~~~~~~~~~~

.. list-table:: Data types
   :header-rows: 1

   * - Identifier
     - Numerical type
     - Size (no. bytes)
     - Byte order
   * - `bool`
     - Boolean, with False encoded as `\x00` and True encoded as `\x01`
     - 1
     - None
   * - `i1`
     - signed integer
     - 1
     - None
   * - `<i2`
     - signed integer
     - 2
     - little-endian
   * - `<i4`
     - signed integer
     - 4
     - little-endian
   * - `<i8`
     - signed integer
     - 8
     - little-endian
   * - `>i2`
     - signed integer
     - 2
     - big-endian
   * - `>i4`
     - signed integer
     - 4
     - big-endian
   * - `>i8`
     - signed integer
     - 8
     - big-endian
   * - `u1`
     - signed integer
     - 1
     - None
   * - `<u2`
     - unsigned integer
     - 2
     - little-endian
   * - `<u4`
     - unsigned integer
     - 4
     - little-endian
   * - `<u8`
     - unsigned integer
     - 8
     - little-endian
   * - `<f2`
     - half precision float: sign bit, 5 bits exponent, 10 bits mantissa
     - 2
     - little-endian
   * - `<f4`
     - single precision float: sign bit, 8 bits exponent, 23 bits mantissa
     - 4
     - little-endian
   * - `<f8`
     - double precision float: sign bit, 11 bits exponent, 52 bits mantissa
     - 8
     - little-endian
   * - `>f2`
     - half precision float: sign bit, 5 bits exponent, 10 bits mantissa
     - 2
     - big-endian
   * - `>f4`
     - single precision float: sign bit, 8 bits exponent, 23 bits mantissa
     - 4
     - big-endian
   * - `>f8`
     - double precision float: sign bit, 11 bits exponent, 52 bits mantissa
     - 8
     - big-endian
   * - `<c8`
     - complex number, represented by two 32-bit floats (real and imaginary components)
     - 8
     - little-endian
   * - `<c16`
     - complex number, represented by two 64-bit floats (real and imaginary components)
     - 16
     - little-endian
   * - `>c8`
     - complex number, represented by two 32-bit floats (real and imaginary components)
     - 8
     - big-endian
   * - `>c16`
     - complex number, represented by two 64-bit floats (real and imaginary components)
     - 16
     - big-endian

Floating point types correspond to basic binary interchange formats as
defined by IEEE 754-2008.


Chunk grids
-----------

A chunk grid defines a set of chunks which contain the elements of an
array. The chunks of a grid form a tessellation of the array space,
which is a space defined by the dimensionality and shape of the
array. This means that every element of the array is a member of one
chunk, and there are no gaps or overlaps between chunks.

In general there are different possible types of grids. The core
protocol defines the regular grid type, where all chunks are
hyperrectangles of the same shape. Protocol extensions may define
other grid types, such as rectilinear grids where chunks are still
hyperrectangles but do not all share the same shape.

A grid type must also defines rules for constructing an identifier for
each chunk that is unique within the grid, which is a string of ASCII
characters that can be used to construct keys to save and retrieve
chunk data in a store, see also the `Storage protocol`_ section.

Regular grids
~~~~~~~~~~~~~

A regular grid is a type of grid where an array is divided into chunks
such that each chunk is a hyperrectangle of the same shape. The
dimensionality of the grid is the same as the dimensionality of the
array. Each chunk in the grid can be addressed by a tuple of positive
integers (`i`, `j`, `k`, ...) corresponding to the indices of the
chunk along each dimension.

The origin vertex of a chunk has coordinates in the array space (`i` *
`dx`, `j` * `dy`, `k` * `dz`, ...) where (`dx`, `dy`, `dz`, ...) are
the grid spacings along each dimension, also known as the chunk
shape. Thus the origin vertex of the chunk at grid index (0, 0, 0,
...) is at coordinate (0, 0, 0, ...) in the array space, i.e., the
grid is aligned with the origin of the array. If the length of any
array dimension is not perfectly divisible by the chunk length along
the same dimension, then the grid will overhang the edge of the array
space.

The shape of the chunk grid will be (ceil(`x` / `dx`), ceil(`y` /
`dy`), ceil(`z` / `dz`), ...)  where (`x`, `y`, `z`, ...) is the array
shape, "/" is the division operator and "ceil" is the ceiling
function. For example, if a 3 dimensional array has shape (10, 200,
3000), and has chunk shape (5, 20, 400), then the shape of the chunk
grid will be (2, 10, 8), meaning that there will be 2 chunks along the
first dimension, 10 along the second dimension, and 8 along the third
dimension.

An element of an array with coordinates (`i`, `j`, `k`, ...) will
occur within the chunk at grid index (`i` // `dx`, `j` // `dy`, `k` //
`dz`, ...), where "//" is the floor division operator. The element
will have coordinates (`i` % `dx`, `j` % `dy`, `k` % `dz`, ...) within
that chunk. For example, @@TODO example.

The identifier for chunk with grid index (`i`, `j`, `k`, ...) is
formed by joining together ASCII string representations of each index
using a separator. The default value for the separator is the period
character ("."), but this may be configured by providing a `separator`
value within the `chunk_grid` metadata object, see the section on
`Array metadata`_ below.

For example, in a 3 dimensional array, the identifier for the chunk at
grid index (1, 23, 45) is the string "1.23.45".

Note that this specification does not consider the case where the
chunk grid and the array space are not aligned at the origin vertices
of the array and the chunk at grid index (0, 0, 0, ...). However,
protocol extensions may define variations on the regular grid type
such that the grid indices may include negative integers, and the
origin vertex of the array may occur at an arbitrary position within
any chunk, which is required to allow arrays to be extended by an
arbitrary length in a "negative" direction along any dimension.


Memory layouts
--------------

An array has a memory layout, which defines the way that the binary
values of the array elements are organised within each chunk to form a
contiguous sequence of bytes. This contiguous binary representation of
a chunk is then the input to the array's chunk encoding pipeline,
described in later sections. Typically, when reading data, an
implementation will load this binary representation into a contiguous
memory buffer to allow direct access to array elements without having
to copy data.

The core protocol defines two types of contiguous memory
layout. However, protocol extensions may define other memory
layouts. Note that there may be an interdependency between memory
layouts and data types, such that certain memory layouts may only be
applicable to arrays with certain data types.

C contiguous memory layout
~~~~~~~~~~~~~~~~~~~~~~~~~~

In this memory layout, the binary values of the array elements are
organised into a sequence such that the last dimension of the array is
the fastest changing dimension, also known as "row-major" order. This
layout is only applicable to arrays with fixed size data types.

For example, for a two-dimensional array with chunk shape (`dx`, `dy`),
the binary values for a given chunk are taken from chunk elements in
the order (0, 0), (0, 1), (0, 2), ..., (`dx` - 1, `dy` - 3), (`dx` - 1, `dy` -
2), (`dx` - 1, `dy` - 1).

F contiguous memory layout
~~~~~~~~~~~~~~~~~~~~~~~~~~

In this memory layout, the binary values of the array elements are
organised into a sequence such that the first dimension of the array
is the fastest changing dimension, also known as "column-major"
order. This layout is only applicable to arrays with fixed size data
types.

For example, for a two-dimensional array with chunk shape (`dx`,
`dy`), the binary values for a given chunk are taken from chunk
elements in the order (0, 0), (1, 0), (2, 0), ..., (`dx` - 3, `dy` -
1), (`dx` - 2, `dy` - 1), (`dx` - 1, `dy` - 1).


Codecs
------

An array may be configured with a chunk encoding pipeline, which is a
sequence of zero or more codecs used to transform the binary
representation of each chunk prior to storage, and to reverse the
transformation during retrieval.

A codec is defined as a pair of algorithms named *encode* and
*decode*. Both of these algorithms transform a sequence of bytes
(input) into another sequence of bytes (output). The *decode*
algorithm is the reverse of the *encode* algorithm, but it is not
required that the reversal is perfect. For example, a codec may be a
lossy compressor for floating point data, which will lose some
numerical precision during encoding and thus not reproduce exactly the
original byte sequence after subsequent decoding. However, if *a* is
the binary representation of a chunk with data type *d* and internal
memory layout *m*, then the result *b = decode(encode(a))* must be
consistent with the data type and memory layout of *a*.

To allow for flexibility to define and implement new codecs, this
specification does not define any codecs, nor restrict the set of
codecs that may be used. Each codec must be defined via a separate
specification. In order to refer to codecs in array metadata
documents, each codec must have a unique identifier, which is a URI
that dereferences to a human-readable specification of the codec. A
codec specification must declare the codec identifier, and describe
(or cite documents that describe) the encoding and decoding algorithms
and the format of the encoded data.

A codec may have configuration parameters which modify the behaviour
of the codec in some way. For example, a compression codec may have a
compression level parameter, which is an integer that affects the
resulting compression ratio of the data. Configuration parameters must
be declared in the codec specification, including a definition of how
configuration parameters are represented as JSON.

The Zarr core development team maintains a repository of codec
specifications, which are hosted alongside this specification in the
`zarr-specs GitHub repository
<https://github.org/zarr-developers/zarr-specs>`_, and which are
published on the `zarr-specs documentation Web site
<http://zarr-specs.readthedocs.io/>`_. For ease of discovery, it is
recommended that codec specifications are contributed to the
zarr-specs GitHub repository. However, codec specifications may be
maintained by any group or organisation and published in any location
on the Web. For further details of the process for contributing a
codec specification to the zarr-specs GitHub repository, see the Zarr
community process specification @@TODO link.

Further details of how a chunk encoding pipeline is configured for an
array are given in the section below on `Array metadata`_.


Metadata
--------

This section defines metadata documents for Zarr arrays and groups. A
Zarr metadata document is a [RFC8259]_ JSON document containing
configuration metadata for a Zarr array or group. In this section, the
terms "value", "number", "string" and "object" are used as defined in
[RFC8259]_. The term "array" is also used as defined in [RFC8259]_ and
means a JSON array, except where qualified as "Zarr array". Following
[RFC8259]_, this section also describes an object as a set of
name/value pairs.

A Zarr array or group metadata document must contain a single object,
here called the metadata object. The following names must be present
in the metadata object and must be used as defined below.

`zarr_format`

    URI of the Zarr core protocol specification that defines the
    metadata format. For Zarr arrays conforming to this specification,
    the value must be the string
    "http://purl.org/zarr/spec/protocol/core/3.0".

    Implementations of this protocol may assume that the final path
    segment of this URI ("3.0") represents the core protocol version
    number, where "3" is the major version number and "0" is the minor
    version number. Implementations of this protocol may also assume
    that future versions of this protocol that retain the same major
    versioning number ("3") will be backwards-compatible, in the sense
    that any new features added to the protocol can be safely
    ignored. In other words, implementations of this protocol may read
    any metadata object where the major version number is "3" and
    interpret the metadata as defined in this specification, ignoring
    any name/value pairs where the name is not defined here.

    Note that this value is given as a URI rather than just as a
    simple version number string to help with discovery of this
    specification.

`extensions`

    Provides protocol extensions which define additional features used
    by the Zarr array or group or other modifications to the metadata
    format. The value must be an array containing zero or more
    objects, each of which identifies an extension and provides any
    additional extension configuration metadata. Each extension
    configuration object must contain the name `extension` whose value
    is a URI that identifies a Zarr protocol extension and
    dereferences to a human readable representation of the extension
    specification. Each object must also contain the name
    `must_understand` whose value is either the literal ``true`` or
    ``false``. Each object may contain other name/value pairs as defined
    by the protocol extension.

    If an implementation of this specification encounters an extension
    that it does not recognise, but the value of `must_understand` is
    ``false``, then the extension may be ignored and processing may
    continue. If the extension is not recognised and the value of
    `must_understand` is ``true`` then processing must terminate and
    an appropriate error raised.

`attributes`

    Provides user- or application-defined metadata. The value must be
    an object, but there are no constraints on what name/value pairs
    the object contains.


Array metadata
~~~~~~~~~~~~~~

In addition to `zarr_format` and `extensions`, a Zarr array metadata
document must also contain the following names, used as defined below.
    
`shape`

    An array of integers providing the length of each dimension of the
    Zarr array. For example, a value ``[10, 20]`` indicates a
    two-dimensional Zarr array, where the first dimension has length
    10 and the second dimension has length 20.

`data_type`

    The data type of the Zarr array. If the data type is defined in
    this specification, then the value must be the data type
    identifier provided as a string. For example, ``"<f8"`` for
    little-endian 64-bit floating point number.

    The `data_type` value is an extension point and may be defined by
    a protocol extension. If the data type is defined by a protocol
    extension, then the value must be an object containing the names
    `extension`, `type` and `fallback`. The `extension` is required
    and its value must be a URI that identifies the protocol extension
    and dereferences to a human-readable representation of the
    specification.  The `type` is required and its value is defined by
    the protocol extension. The `fallback` is optional and, if
    provided, its value must be one of the data type identifiers
    defined in this specification. If an implementation does not
    recognise the extension, but a `fallback` is present, then the
    implementation may proceed using the `fallback` value as the data
    type. The object may also contain other name/value pairs as
    defined by the protocol extension.

`chunk_grid`

    The chunk grid of the Zarr array. If the chunk grid is a regular
    chunk grid as defined in this specification, then the value must
    be an object with the names `type` and `chunk_shape`. The value of
    `type` must be the string ``"regular"``, and the value of
    `chunk_shape` must be an array of integers providing the lengths
    of the chunk along each dimension of the array. For example,
    ``{"type": "regular", "chunk_shape": [2, 5]}`` means a regular
    grid where the chunks have length 2 along the first dimension and
    length 5 along the second dimension.

    The `chunk_grid` value is an extension point and may be defined by
    a protocol extension. If the chunk grid type is defined by a
    protocol extension, then the value must be an object containing
    the names `extension` and `type`. The `extension` is required and
    the value must be a URI that identifies the protocol extension and
    dereferences to a human-readable representation of the
    specification.  The `type` is required and the value is defined by
    the protocol extension. The object may also contain other
    name/value pairs as defined by the protocol extension.

`chunk_memory_layout`

    The internal memory layout of the chunks. Use the value ``"C"`` to
    indicate C contiguous memory layout or ``"F"`` to indicate F
    contiguous memory layout as defined in this specification @@TODO
    link to sections@@.

    The `chunk_memory_layout` value is an extension point and may be
    defined by a protocol extension. If the chunk memory layout type
    is defined by a protocol extension, then the value must be an
    object containing the names `extension` and `type`. The
    `extension` is required and the value must be a URI that
    identifies the protocol extension and dereferences to a
    human-readable representation of the specification.  The `type` is
    required and the value is defined by the protocol extension. The
    object may also contain other name/value pairs as defined by the
    protocol extension.

`chunk_codecs`

    Specifies a sequence of zero or more codecs to be used for
    encoding and decoding chunks. The value must be an array, where
    each member of the array is an object that provides configuration
    metadata for a codec. Each codec configuration object must contain
    the name `codec` whose value is a URI that identifies a codec and
    dereferences to a human readable representation of the codec
    specification. Each codec configuration object may contain other
    name/value pairs providing addition configuration metadata, as
    defined by the corresponding codec specification.

    The codec configuration objects must be given in the order that
    the codecs are applied during chunk encoding. I.e., the first
    codec configuration object defines the first codec applied during
    chunk encoding, and the last codec applied during chunk decoding.

`fill_value`

    Provides an element value to use for uninitialised portions of the
    Zarr array.

    If the data type of the Zarr array is Boolean then the value must
    be the literal ``false`` or ``true``. If the data type is one of
    the integer data types defined in this specification, then the
    value must be a number with no fraction or exponent part and must
    be within the range of the data type. TODO what about floating
    point data types? TODO what about complex data types? TODO what
    about nan and inf? TODO what about extension data types?

    For any data type, if the `fill_value` is the literal `null` then
    the fill value is undefined and the implementation may use any
    arbitrary value that is consistent with the data type as the fill
    value.

All other names are reserved for future versions of this
specification. Implementations and protocol extensions must not define
or use any other names within the metadata object. Any additional
metadata must be provided elsewhere, e.g., within any of the extension
point values, or within the `extensions`, or in a separate metadata
object stored under a different key in the store. See also the section
on `Protocol extensions`_ below.

For example, the JSON document below defines a two-dimensional array
of 64-bit little-endian floating point numbers, with 10000 and 1000
columns, divided into a regular chunk grid where each chunk has 1000
rows and 100 columns, and thus there will be 100 chunks in total
arranged into a 10 by 10 grid. Within each chunk the binary values are
laid out in C contiguous order. Each chunk is compressed using gzip
compression prior to storage::

    {
        "zarr_format": "http://purl.org/zarr/spec/protocol/core/3.0",
	"shape": [10000, 1000],
	"data_type": "<f8",
	"chunk_grid": {
	    "type": "regular",
	    "chunk_shape": [1000, 100]
	},
	"chunk_memory_layout": "C",
	"chunk_codecs": [
            {
	        "codec": "http://purl.org/zarr/spec/codec/gzip",
		"level": 1
	    }
	],
	"fill_value": "NaN",
	"extensions": [],
	"attributes": {
	    "foo": 42,
	    "bar": "apples",
	    "baz": [1, 2, 3, 4]
	}
    }


Group metadata
~~~~~~~~~~~~~~

A Zarr group metadata object must contain the `zarr_format`,
`extensions` and `attributes` names as defined above. All other names
are reserved for future versions of this
specification. Implementations and protocol extensions must not define
or use any other names within the metadata object. Any additional
metadata must be provided elsewhere, e.g., within any of the extension
point values, or within the `extensions`, or in a separate metadata
object stored under a different key in the store. See also the section
on `Protocol extensions`_ below.

For example, the JSON document below defines a group::

    {
        "zarr_format": "http://purl.org/zarr/spec/protocol/core/3.0",
	"extensions": [],
	"attributes": {
	    "spam": "ham",
	    "eggs": 42,
	}
    }


Store interface
---------------

TODO define the store interface


Storage protocol
----------------

TODO define how high level operations like creating a group or array 
translate into low level key/value operations on the store interface


Protocol extensions
-------------------

TODO define different types of protocol extension.


References
----------

.. [RFC8259] T. Bray, Ed. The JavaScript Object Notation (JSON) Data
   Interchange Format. December 2017. Best Current Practice. URL:
   https://tools.ietf.org/html/rfc8259

.. [RFC2119] S. Bradner. Key words for use in RFCs to Indicate
   Requirement Levels. March 1997. Best Current Practice. URL:
   https://tools.ietf.org/html/rfc2119
